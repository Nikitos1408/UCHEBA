
## 2. Тема 1: Асинхронное программирование

### 2.1. q1_1
**Ответ:** b) GIL - это глобальная блокировка, которая позволяет только одному потоку выполнять байт-код Python в любой момент времени, что ограничивает параллелизм для CPU-bound задач.

---

### 2.2. q1_2
**Ответ:** a), b), c)  

---

### 2.3. q1_3
**Ответ:** a), b), c), d)  

---

### 2.4. q1_4
**Конкурентность (concurrency)** — это способность программы управлять несколькими задачами, которые логически выполняются «одновременно», но физически могут чередоваться на одном ядре (кооперативно или с вытеснением).  
**Параллелизм (parallelism)** — фактическое одновременное выполнение нескольких задач на разных ядрах/процессорах.  
**Когда что лучше:**  
- Конкурентность удобна для обработки большого числа I/O‑операций (сетевые запросы, дисковые операции) в одном процессе, например сервер, обслуживающий тысячи подключений.  
- Параллелизм предпочтителен для тяжёлых вычислений (CPU-bound), например обучения модели, обработки изображений, когда задачи можно разбить и реально выполнять на разных ядрах.

---

### 2.5. q1_5

```python
import threading
import time


def worker(num: int) -> None:
    now = time.strftime("%Y-%m-%d %H:%M:%S")
    print(f"Поток {num}: текущее время {now}")


threads = []
for i in range(1, 4):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

---

## 3. Тема 2: Django REST Framework

### 3.1. q2_1
**Ответ:** b) Сериализаторы преобразуют сложные типы данных (модели Django, QuerySet) в JSON/XML и обратно, а также выполняют валидацию.

---

### 3.2. q2_2
**Ответ:** a), b), c), e)  

---

### 3.3. q2_3
**Ответ:** a), b), d), e)  

---

### 3.4. q2_4 
Принцип **REST stateless** означает, что сервер не хранит состояние пользовательской сессии между запросами: каждый запрос должен содержать всю необходимую информацию для его обработки.  
Это важно для масштабируемости, потому что:  
- запросы можно обрабатывать любым экземпляром сервера за балансировщиком,  
- упрощается горизонтальное масштабирование и отказоустойчивость,  
- состояние переносится на клиент или хранится в общих хранилищах, а не в памяти конкретного процесса.

---

### 3.5. q2_5

```python
# models.py
from django.db import models


class Book(models.Model):
    title = models.CharField(max_length=255)
    author = models.CharField(max_length=255)
    published_date = models.DateField()

    def __str__(self):
        return self.title
```

```python
# serializers.py
from rest_framework import serializers
from .models import Book


class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = ["id", "title", "author", "published_date"]
```

```python
# views.py
from rest_framework import generics
from .models import Book
from .serializers import BookSerializer


class BookListCreateView(generics.ListCreateAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
```

```python
# urls.py
from django.urls import path
from .views import BookListCreateView

urlpatterns = [
    path("books/", BookListCreateView.as_view(), name="book-list-create"),
]
```

---

## 4. Тема 3: Spring Boot

### 4.1. q3_1
**Ответ:** b) `@RestController`.

---

### 4.2. q3_2
**Ответ:** a), b), c), e)  

---

### 4.3. q3_3
**Ответ:** a), b), d), e)  

---

### 4.4. q3_4 
Встроенная база данных H2 в Spring Boot — это лёгкая in-memory/файловая реляционная БД, которая автоматически поднимается вместе с приложением.  
Чаще всего её используют для разработки, демо и тестирования:  
- не нужно отдельно разворачивать внешнюю БД,  
- схемы можно быстро менять и пересоздавать,  
- есть встроенная веб-консоль для просмотра данных.  
Преимущества: простота настройки (`spring-boot-starter-data-jpa` + драйвер H2), скорость, изолированность окружения разработчика и удобство написания интеграционных тестов.

---

### 4.5. q3_5

`Task.java`:

```java
package com.example.demo.task;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PrePersist;
import java.time.Instant;

@Entity
public class Task {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(length = 2000)
    private String description;

    @Column(nullable = false)
    private String status;

    @Column(nullable = false, updatable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        this.createdAt = Instant.now();
        if (this.status == null) {
            this.status = "NEW";
        }
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }
}
```

`TaskRepository.java`:

```java
package com.example.demo.task;

import org.springframework.data.jpa.repository.JpaRepository;

public interface TaskRepository extends JpaRepository<Task, Long> {
}
```

---

## 5. Тема 4: OAuth 2.0

### 5.1. q4_1
**Ответ:** c) Authorization Server.

---

### 5.2. q4_2
**Ответ:** a), b), c), d)  

---

### 5.3. q4_3
**Ответ:** a), b), c), d)  

---

### 5.4. q4_4 
Аутентификация (authentication) — проверка, кто пользователь (подтверждение личности: логин/пароль, токен, сертификат).  
Авторизация (authorization) — проверка, что конкретный аутентифицированный пользователь имеет право выполнить действие или получить доступ к ресурсу.  
OAuth 2.0 решает в первую очередь задачу авторизации: выдачу клиенту ограниченного доступа к ресурсам от имени пользователя через токены (а не передачу логина/пароля клиенту).

---

### 5.5. q4_5 
В OAuth 2.0 участвуют роли:  
- Resource Owner — владелец ресурса.  
- Client — приложение, которое хочет получить доступ к защищённым ресурсам.  
- Authorization Server — сервер авторизации, который аутентифицирует пользователя и выдаёт токены.  
- Resource Server — сервер ресурсов, который защищает API и принимает access token.  

Основные шаги Authorization Code Flow:  
1. Клиент перенаправляет пользователя на Authorization Server с параметрами `client_id`, `redirect_uri`, `scope`, `state` и `response_type=code`.  
2. Пользователь аутентифицируется на сервере авторизации и подтверждает доступ клиенту.  
3. Authorization Server перенаправляет пользователя обратно на `redirect_uri`, добавляя авторизационный код (`code`) и переданный ранее `state`.  
4. Клиент (на своём бэкенде) отправляет запрос на Authorization Server с `code`, `client_id`, `client_secret` и `redirect_uri`, чтобы обменять код на `access_token` (и, опционально, `refresh_token`).  
5. Клиент использует `access_token` для обращений к Resource Server.  

Назначение `redirect_uri` и `state`:  
- `redirect_uri` определяет, куда сервер авторизации вернёт пользователя после аутентификации, и защищает от подмены адреса.  
- `state` используется для защиты от CSRF: клиент генерирует случайное значение и сверяет его при возврате.  

Разница между access token и refresh token:  
- `access_token` — краткоживущий токен, используемый в запросах к Resource Server.  
- `refresh_token` — более долгоживущий токен, который хранится только на стороне доверенного клиента и используется для получения новых `access_token` без повторной аутентификации пользователя.

---

## 6. Тема 5: REST API и OpenAPI

### 6.1. q5_1
**Ответ:** b) PUT.

---

### 6.2. q5_2
**Ответ:** a), b), c), d)  

---

### 6.3. q5_3
**Ответ:** a), b), c), d)  

---

### 6.4. q5_4  
OpenAPI — это спецификация (формальный язык описания) REST API: эндпоинты, методы, параметры, схемы запросов/ответов, коды ошибок и т.д.  
Swagger — набор инструментов вокруг OpenAPI: редакторы, генераторы документации, клиенты и серверные заглушки, UI для интерактивного тестирования.  
Различие: OpenAPI — это стандарт/формат, Swagger — реализация и инструменты. Они связаны тем, что Swagger исторически дал начало спецификации, а современные версии Swagger-инструментов используют OpenAPI-описания.

---

### 6.5. q5_5

```python
from fastapi import FastAPI
from pydantic import BaseModel


app = FastAPI()


class ItemResponse(BaseModel):
    item_id: int
    name: str
    description: str | None = None


@app.get("/items/{item_id}", response_model=ItemResponse)
async def get_item(item_id: int):
    return ItemResponse(
        item_id=item_id,
        name=f"Item #{item_id}",
        description="Пример ответа FastAPI",
    )
```

---

## 7. Тема 6: Линейное программирование и оптимизация

### 7.1. q6_1
**Ответ:** a) Целевая функция, система ограничений, условия неотрицательности переменных.

---

### 7.2. q6_2
**Ответ:** a), b), c), e)  

---

### 7.3. q6_3
**Ответ:** a), b), c), d)  

---

### 7.4. q6_4 
Функция Лагранжа строится как целевая функция плюс линейная комбинация ограничений с множителями Лагранжа.  
Множители Лагранжа — дополнительные переменные, которые «наказывают» нарушение ограничений и позволяют превратить задачу с ограничениями в задачу без явных ограничений (но с новой функцией).  
В задачах условной оптимизации метод Лагранжа и условия ККТ позволяют находить точки, где оптимум по целевой функции достигается при выполнении всех ограничений, а также анализировать двойственные задачи и тени цен ограничений.

---

### 7.5. q6_5

```python
from scipy.optimize import linprog

c = [-2, -3]
A_ub = [[1, 1]]
b_ub = [10]
bounds = [(0, None), (0, None)]

result = linprog(c=c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method="highs")

if result.success:
    x_opt, y_opt = result.x
    F_max = 2 * x_opt + 3 * y_opt
    print(f"x* = {x_opt:.2f}, y* = {y_opt:.2f}, F_max = {F_max:.2f}")
else:
    print("Задача не решена:", result.message)
```

---

## 8. Тема 7: Микросервисная архитектура и RabbitMQ

### 8.1. q7_1
**Ответ:** b) RabbitMQ - это брокер сообщений, обеспечивающий асинхронную коммуникацию между сервисами через очереди.

---

### 8.2. q7_2
**Ответ:** a), b), c), e)  

---

### 8.3. q7_3
**Ответ:** a), b), c), d)  

---

### 8.4. q7_4 
Correlation ID — это уникальный идентификатор, который добавляется к сообщению и «путешествует» вместе с ним по всем очередям и сервисам.  
Он позволяет:  
- связывать запрос и ответ в асинхронной системе,  
- отслеживать цепочку обработки сообщения (tracing, логирование),  
- облегчать отладку и мониторинг распределённых систем.  
Например, фронтенд генерирует Correlation ID для запроса, а все микросервисы записывают его в логи — так можно восстановить полный путь обработки.

---

### 8.5. q7_5

```yaml
version: "3.9"

services:
  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: user
      RABBITMQ_DEFAULT_PASS: password
```

---

## 9. Тема 8: Apache Camel и интеграционные паттерны

### 9.1. q8_1
**Ответ:** b) Apache Camel - это интеграционный фреймворк, реализующий Enterprise Integration Patterns для связи различных систем.

---

### 9.2. q8_2
**Ответ:** a), b), d), e)  

---

### 9.3. q8_3 
В типичном интеграционном решении сообщения собираются из разных источников: HTTP‑API, файловых хранилищ, очередей сообщений, БД, датчиков и т.д. Специальные адаптеры/коннекторы принимают данные и помещают их в унифицированный канал (message channel). Затем маршрутизаторы (router, content-based router) направляют сообщения в нужные подсистемы в зависимости от содержимого и метаданных.  
По пути сообщения могут преобразовываться (message translator), обогащаться дополнительными данными из других систем (enricher), агрегироваться или, наоборот, разбиваться (aggregator/splitter). Для отказоустойчивости и надёжности используются очереди, повторные попытки, dead letter channel и корреляция сообщений.  
Мониторинг и наблюдаемость обеспечиваются логированием, метриками, трассировкой (tracing): каждое сообщение помечается Correlation ID, события маршрутизации пишутся в централизованный лог/систему мониторинга, что позволяет анализировать производительность и отказы.

---

### 9.4. q8_4 
Паттерн Wire Tap — это «ответвление» сообщения в параллельный поток без влияния на основной маршрут.  
Основное сообщение продолжает идти по своему нормальному пути, а его копия отправляется в дополнительный канал/очередь, где может использоваться для логирования, мониторинга, аналитики, аудита или асинхронной постобработки.  
Преимущество: можно добавлять наблюдение и побочные действия без изменения бизнес‑логики основного потока.

---

### 9.5. q8_5

```java
package com.example.routes;

import org.apache.camel.builder.RouteBuilder;
import org.springframework.stereotype.Component;

@Component
public class PriceRoute extends RouteBuilder {

    @Override
    public void configure() {
        from("jms:queue:input-prices")
            .routeId("price-filter-route")
            .unmarshal().json()
            .filter(simple("${body[price]} > 100"))
                .to("jms:queue:expensive-items")
            .end();
    }
}
```


